=> Perfomance of Heap compared to other DS


			    Insertion      Search      Find_Min      Delete_Min

Unsorted Array     O(1)  	   O(N)  	   O(N) 	     O(N)	                                              

Sorted Array       O(N)  	   O(logN)     O(1) 	     O(N)                                                    

Unsorted LL        O(1)  	   O(N)  	   O(N) 	     O(N)                                                       

Sorted LL          O(1)  	   O(logN)     O(1) 	     O(1)  

Min Heap           O(logN)     O(N)        O(1)          O(logN)


HEAP => 1. Tree DS
	  2. Complete Binary Tree
	  3. Heap property (keep track of max/min element at root).
	  4. are of two types (max and min).


Max-Heap => Root should always be maximum and same goes for all sub trees.
Min-Heap => Root should always be minimum and same goes for all sub trees.

Heap Representation => Node -> i
			     parent -> floor(i-1/2)
			     left child -> 2*i + 1
			     right child -> 2*i + 2 	

Insertion In Heap => First insert element at last and then swap with parent till the heap property is satisfied

Deletion in heap => first delete the root element from heap and then put last element at root and swap with children till the 
			  heap property is satisfied.

Heapify => An algorithm to make the heap from regular array having time complexity of O(n). Traverse array from the end(n/2) since leaf are bound 
	     to be heap and check if the current node is forming a heap, if not then swap with the max(leftchild, rightchild) else continue.

Heapsort => Takes O(NlogN). Delete the element from heap N times.

Heap in cpp stl => 1. Max Heap -> priority_queue<d_type>, push , pop, top , size, empty.
			 2. Min Heap -> priority_queue<int, vector<int>, greater<int>>

Question Identification => Kth + `Smalles/Largest`
                                      |      |
                                     Max    Min
                                    Heap    Heap
                    
                        => Question could be solvable by sorting(NlogN) and then can be improved by heap(NlogK or N).

=> Questions

1.  Kth Largest Element in an Array -> Given an integer array nums and an integer k, return the kth largest element in the array.
// code => 
 int findKthLargest(vector<int>& nums, int k) {
    priority_queue<int,vector<int>,greater<int>> pq;
    for(int i=0; i<nums.size(); i++){    // O(n)
        pq.push(nums[i]);                // O(logK)
        if(pq.size()>k) pq.pop();
    }
    return pq.top();
}


1.  Kth Smallest Element in an Array -> Given an integer array nums and an integer k, return the kth Smallest element in the array.
// code => 
int kthSmallest(int arr[], int l, int r, int k) {
    priority_queue<int> pq;
    for(int i=l; i<=r; i++){
        pq.push(arr[i]);
        
        if(pq.size()>k) pq.pop();
    }
    return pq.top();
}










